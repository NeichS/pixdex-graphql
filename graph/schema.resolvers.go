package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"
	"fmt"

	"github.com/NeichS/graphql-pixdex/data"
	"github.com/NeichS/graphql-pixdex/graph/model"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// CreateContenidoAudiovisual is the resolver for the createContenidoAudiovisual field.
func (r *mutationResolver) CreateContenidoAudiovisual(ctx context.Context, input model.NuevoContenidoAudioVisual) (*model.ContenidoAudioVisual, error) {
	if input.Nombre == "" {
		return nil, fmt.Errorf("el nombre del contenido audiovisual es obligatorio")
	}
	if input.Descripcion == "" {
		return nil, fmt.Errorf("la descripcion del contenido audiovisual es obligatoria")
	}
	if len(input.Generos) == 0 {
		return nil, fmt.Errorf("debe seleccionar al menos un genero")
	}
	if input.TipoID == "" {
		return nil, fmt.Errorf("el tipo de contenido audiovisual es obligatorio")
	}

	contenido := &model.ContenidoAudioVisual{
		ID:          "99",
		Nombre:      input.Nombre,
		Descripcion: &input.Descripcion,
		ImageURL:    input.ImageURL,
		TipoID:      input.TipoID,
		Generos:     input.Generos,
	}
	return contenido, nil
}

// CreateGenero is the resolver for the createGenero field.
func (r *mutationResolver) CreateGenero(ctx context.Context, input model.NuevoGenero) (*model.Genero, error) {
	if input.Nombre == "" {
		return nil, fmt.Errorf("el nombre del genero es obligatorio")
	}

	genero := &model.Genero{
		ID:     "99",
		Nombre: input.Nombre,
	}
	return genero, nil
}

// CreateTipoContenidoAudioVisual is the resolver for the createTipoContenidoAudioVisual field.
func (r *mutationResolver) CreateTipoContenidoAudioVisual(ctx context.Context, input model.NuevoTipoContenidoAudioVisual) (*model.TipoContenidoAudioVisual, error) {
	if input.Plural == "" || input.Singular == "" {
		return nil, &gqlerror.Error{
			Message:    fmt.Sprintf("Invalid plural"),
			Extensions: map[string]interface{}{"code": "INVALID_INPUT"},
		}
	}
	return &model.TipoContenidoAudioVisual{
		ID:       "99",
		Singular: input.Singular,
		Plural:   input.Plural,
	}, nil
}

// UpdateContenidoNombre is the resolver for the updateContenidoNombre field.
func (r *mutationResolver) UpdateContenidoNombre(ctx context.Context, id string, newNombre string) (*model.ContenidoAudioVisual, error) {
	contenido, err := data.GetContenidoPorID(id)

	if err != nil {
		return nil, &gqlerror.Error{
			Message:    fmt.Sprintf("Contenido con ID %s no existe", id),
			Extensions: map[string]interface{}{"code": "NOT_FOUND"},
		}
	}

	return &model.ContenidoAudioVisual{
		ID:          contenido.ID,
		Nombre:      newNombre,
		Descripcion: contenido.Descripcion,
		Generos:     contenido.Generos,
		TipoID:      contenido.TipoID,
		ImageURL:    contenido.ImageURL,
	}, nil
}

// UpdateContenidoDescripcion is the resolver for the updateContenidoDescripcion field.
func (r *mutationResolver) UpdateContenidoDescripcion(ctx context.Context, id string, newDescripcion string) (*model.ContenidoAudioVisual, error) {
	contenido, err := data.GetContenidoPorID(id)

	if err != nil {
		return nil, &gqlerror.Error{
			Message:    fmt.Sprintf("Contenido con ID %s no existe", id),
			Extensions: map[string]interface{}{"code": "NOT_FOUND"},
		}
	}

	return &model.ContenidoAudioVisual{
		ID:          contenido.ID,
		Nombre:      contenido.Nombre,
		Descripcion: &newDescripcion,
		Generos:     contenido.Generos,
		TipoID:      contenido.TipoID,
		ImageURL:    contenido.ImageURL,
	}, nil
}

// UpdateContenidoTipo is the resolver for the updateContenidoTipo field.
func (r *mutationResolver) UpdateContenidoTipo(ctx context.Context, id string, newTipoID string) (*model.ContenidoAudioVisual, error) {
	contenido, err := data.GetContenidoPorID(id)

	if err != nil {
		return nil, &gqlerror.Error{
			Message:    fmt.Sprintf("Contenido con ID %s no existe", id),
			Extensions: map[string]interface{}{"code": "NOT_FOUND"},
		}
	}

	return &model.ContenidoAudioVisual{
		ID:          contenido.ID,
		Nombre:      contenido.Nombre,
		Descripcion: contenido.Descripcion,
		Generos:     contenido.Generos,
		TipoID:      newTipoID,
		ImageURL:    contenido.ImageURL,
	}, nil
}

// UpdateContenidoGeneros is the resolver for the updateContenidoGeneros field.
func (r *mutationResolver) UpdateContenidoGeneros(ctx context.Context, id string, newGeneros []string) (*model.ContenidoAudioVisual, error) {
	contenido, err := data.GetContenidoPorID(id)

	if err != nil {
		return nil, &gqlerror.Error{
			Message:    fmt.Sprintf("Contenido con ID %s no existe", id),
			Extensions: map[string]interface{}{"code": "NOT_FOUND"},
		}
	}

	return &model.ContenidoAudioVisual{
		ID:          contenido.ID,
		Nombre:      contenido.Nombre,
		Descripcion: contenido.Descripcion,
		Generos:     newGeneros,
		TipoID:      contenido.TipoID,
		ImageURL:    contenido.ImageURL,
	}, nil
}

// UpdateContenidoImageURL is the resolver for the updateContenidoImageUrl field.
func (r *mutationResolver) UpdateContenidoImageURL(ctx context.Context, id string, newImageURL string) (*model.ContenidoAudioVisual, error) {
	contenido, err := data.GetContenidoPorID(id)

	if err != nil {
		return nil, &gqlerror.Error{
			Message:    fmt.Sprintf("Contenido con ID %s no existe", id),
			Extensions: map[string]interface{}{"code": "NOT_FOUND"},
		}
	}

	return &model.ContenidoAudioVisual{
		ID:          contenido.ID,
		Nombre:      contenido.Nombre,
		Descripcion: contenido.Descripcion,
		Generos:     contenido.Generos,
		TipoID:      contenido.TipoID,
		ImageURL:    &newImageURL,
	}, nil
}

// ContenidoAudioVisual is the resolver for the ContenidoAudioVisual field.
func (r *queryResolver) ContenidoAudioVisual(ctx context.Context) ([]*model.ContenidoAudioVisual, error) {
	var contenidoMapped []*model.ContenidoAudioVisual
	return contenidoMapped, nil
}

// ContenidoAudioVisualMapped is the resolver for the ContenidoAudioVisualMapped field.
func (r *queryResolver) ContenidoAudioVisualMapped(ctx context.Context, page int32) ([]*model.ContenidoAudioVisualMapped, error) {
	idLimit :=  make(map[int32][]int, 0)
	idLimit[1] = []int{0 , 20}
	idLimit[2] = []int{20 , 40}
	idLimit[3] = []int{40 , 60}
	
	if page < 1 || page > 3 {
		return nil, &gqlerror.Error{
			Message:    fmt.Sprintf("Page %d is out of range. Valid pages are 1 to 3.", page),
		}
	}

	var contenidoMapped []*model.ContenidoAudioVisualMapped
	for i := idLimit[page][0]; i < idLimit[page][1]; i++ {
		contenidoMapped = append(contenidoMapped, data.MapContenidoAudioVisual(data.ContenidosAudiovisuales[i]))
	}
	return contenidoMapped, nil
}

// Contenido is the resolver for the contenido field.
func (r *queryResolver) Contenido(ctx context.Context, id string) (*model.ContenidoAudioVisualMapped, error) {
	contenidoMapped, err := data.GetContenidoPorID(id)
	if err != nil {
		return nil, &gqlerror.Error{
			Message:    fmt.Sprintf("Contenido con ID %s no existe", id),
			Extensions: map[string]interface{}{"code": "NOT_FOUND"},
		}
	}
	return data.MapContenidoAudioVisual(contenidoMapped), nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
